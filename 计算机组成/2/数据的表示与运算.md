---
title: 数据的表示与运算
index_img: /post_index_img/
date: 2020-05-27 13:11:14
categories:
    - 计算机组成
tags:
    - 计算机组成
---

![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-31-15-50-39.png)


# 1. 数制与编码

## 1.1. 进位计数制及其相互转换

1. 进位计数法
2. 进制转换
   1. 二-->八,十六
      ![image-20200527132700461](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527132700461.png)
   2. 十-->二/八   (基数乘除法)
      1. 除基取余法
         ![image-20200527132804232](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527132804232.png)
      2. 乘基取整法
         ![image-20200527132820341](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527132820341.png)

## 1.2. 真值和机器数

真值: 机器数代表的实际值
机器数: 符号"数字化"的数

## 1.3. BCD码

二进制编码的十进制数(Binary-Coded Decimal, BCD)  
四位二进制数$\overset{表示}{\rightarrow}$0-9

1. $8421$码
   1. $>9\rightarrow+6$进位修正
      ![image-20200527135521518](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527135521518.png)
2. 余三码
   1. $8421+(0011)_{2}$
3. $2421$码

## 1.4. 字符&字符串

1. 字符编码`ASCII`码
   1. 7位(10数+52字母+专用符号=128)

## 1.5. 校验码

增加冗余码, 检验或者纠错编码  

**码距**: 任意两个合法码字之间最少变化的二进制位数, 码距大于2-->检错能力(>=纠错能力)

### 1.5.1. 奇偶校验码

码距: 2
检测: 奇数位错误
纠正: none 

校验码中"1"的个数
<img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527143628328.png" alt="image-20200527143628328" style="zoom:80%;" />

### 1.5.2. 海明(汉明)校验码

码距: 大于2
检测: 一位数据错误
纠正: 一位数据错误

- $2^k\geqslant n+k+1$
  - 发现一位错
  - 纠正一位错
- $2^{k-1}\geqslant n+k$
  - 发现两位错
  - 纠正一位错

全校验位: 对所有进行偶校验

![image-20200527145716728](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527145716728.png)

### 1.5.3. 循环冗余校验(CRC)码/(N,K)码

<img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527145940212.png" alt="image-20200527145940212" style="zoom:80%;" />

- 原理: 线性编码理论
  - 适当多项式$G(x)$
  - $M(x)$长度确定
    - 余数$\Leftrightarrow$`CRC`码出错位
  - 检错: 接收$CRC$与$G(x)$相除
    - 余数$=0\rightarrow$正确
    - 余数$\neq 0$有错
      - $G(x)$选的好$\rightarrow$判断出错位
- 检测: 一位 || 多位(与多项式的选取有关)
- 适用: 计算机网络的数据链路层, 大量数据的数据校验	

![image-20200527150442058](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527150442058.png)


# 2. 定点数的

## 2.1. 定点数的表示

### 2.1.1. 原码

- 纯小数

$$
[x]_{\text{原}}=\begin{cases}
   x & ,1>x\geqslant 0 \\ 
   1-x=1+|x| & ,0\geqslant x>-1
\end{cases}
$$

- 纯整数

$$
[x]_{\text{原}}=\begin{cases}
   0,x & , 2^{n}>x\geqslant 0 \\
   2^{n}-x=2^{n}+|x| & ,0\geqslant x>-2^{n}
\end{cases}
$$

### 2.1.2. 补码

- 纯小数

$$
[x]_{\text{补}}=\begin{cases}
   x & ,1>x\geqslant 0 \\
   2+x=2-|x| & ,0>x\geqslant -1
\end{cases}(\mod 2)
$$

- 纯整数

$$
[x]_{\text{补}}=\begin{cases}
   0,x & ,2^{n}>x\geqslant 0 \\
   2^{n+1}+x=2^{n+1}-|x| & ,0\geqslant x\geqslant -2^{n}
\end{cases}(\mod 2^{n+1})
$$

- 原码求补码
  - 正数: $[x]_{\text{补}}=[x]_{\text{原}}$
  - 负数: 取反加一
- 补码算数位移
  
  - $[x]_{\text{补}}\text{符号位}\&\text{数值位}\rightarrow\text{右移}\&\text{保持符号位值不变}\rightarrow\text{除法功能}.$
- 变形补码
  - $$
    [x]_{\text{补}}=\begin{cases}
       x & ,1>x>0 \\
       4+x=4-|x| & ,0>x\geqslant -1
    \end{cases}(\mod 4)
    $$
  - ALU部件--00正,11负

### 2.1.3. 反码

- 纯小数

$$
[x]_{\text{反}}=
\begin{cases}
   x & ,1>x\geqslant 0 \\
   (2-2^{-n})+x & ,0\geqslant x>-1
\end{cases}(\mod 2-2^{-n})
$$

- 纯整数

$$
[x]_{\text{反}}=
\begin{cases}
   0,x & ,2^{n}>x\geqslant 0 \\
   (2^{n+q}-1)+x & ,0\geqslant x>-2^{n}
\end{cases}
$$

#### 2.1.3.1. 转换

![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-12-54-58.png)

- 原码$\Leftrightarrow$补码: 符号位不变,左数第一个1(不包括)之前全反

### 2.1.4. 移码

$$
[x]_{\text{移}}=2^{n}+x(2^{n}>x\geqslant -2^{n},\text{机器字长}n+1)
$$

![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-30-15-13-16.png)

- 0表示唯一
- $[x]_{\text{补}}\overset{符号位反转}{=}[x]_{\text{移}}$
- 移码大$\rightarrow$真值大

## 2.2. 定点数的运算

### 2.2.1. 移位运算

1. 算数移位: 有符号
   1. 移位--符号位不变  
   <img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-13-50-55.png" width="600px"/>
   <img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-13-53-27.png" width="700px"/>
2. 逻辑移位: 无符号(逻辑代码)
   1. 都--移丢添0
3. 循环移位
   <img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-13-56-54.png" width="700px"/>

### 2.2.2. 原码定点数的加减运算

左边溢出-->丢掉

### 2.2.3. 补码定点数加减法运算

1. 操作数用补码
2. 逢二进一
3. 符号位&数值位参与运算
4. 移丢
5. 公式

$$
\begin{aligned}
&[A+B]_{\text{补}}=[A]_{\text{补}}+[B]_{\text{补}}\ (\mod M)\\
&[A-B]_{\text{补}}=[A]_{\text{补}}+[-B]_{\text{补}}\ (\mod M)\\
&\text{定点小数}\rightarrow M=2\\
&\text{定点整数}\rightarrow M=2^{n+1}\\
&M\rightarrow\text{移丢}
\end{aligned}
$$
![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-14-27-50.png)

### 2.2.4. 符号扩展

- 正数
  - 符号位-->新符号位, 其他填充0
- 负数
  - 补码
    - 符号位-->新符号位
      - 整数-->填充1
      - 小数-->填充0
  - 反码
    - 符号位-->新符号位
    - 填充1

### 2.2.5. 溢出概念&判别方法

- 补码
  - 一位符号位
    - 操作数符号相同, 结果符号不同-->溢出
      ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-14-41-55.png)
  - 双符号位(模4补码)
    - ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-14-43-45.png)
  - 一位符号位根据数据位的进位
    - ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-14-45-56.png)
  - 表示范围
    - 例如8位补码-->-128~+127
      - $[x]_{\text{补}}$算出$[x]_{\text{原}}\rightarrow看超不超范围$

### 2.2.6. 定点数的乘法运算

- 原码一位乘
  - ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-14-51-58.png)
  - ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-14-52-18.png)
- 补码一位乘
  - ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-15-06-41.png)
  ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-15-07-14.png)
  ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-15-08-28.png)
- 总结
   ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-15-09-26.png)

### 2.2.7. 定点数除法

- 原码除法(不恢复余数法/原码加减交替除法)
  - ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-15-13-50.png)
  ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-15-14-03.png)
  ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-15-15-11.png)
- 补码除法运算(加减交替法)
  - ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-15-24-25.png)
  ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-15-24-43.png)
  ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-15-25-15.png)
- 除法总结
   ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-15-25-41.png)

## 2.3. C语言整数与类型转换

- 高位补原数字的符号位

## 2.4. 数据的存储和排列

### 2.4.1. 大小端

- `int`,`float`: 4字节
- `double`: 8字节

1. 高字节低字节
   如`int a=16777220`，化为十六进制是`0x01 00 00 04`则`04`属于低字节，01属于高字节
2. 大小端模式
   （1）如果a在内存中的存放顺序为下图（即低字节存放在高地址），则为大端模式
   <img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/20180923183740810" alt="img" style="zoom:50%;" />
   （2）如果a在内存中的存放顺序为下图（即低字节存放在低地址），则为小端模式
   <img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/20180923183653465" alt="img" style="zoom:50%;" />
   (指针在低地址 0x001)

### 2.4.2. 边界对齐

![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-16-08-02.png)

# 3. 浮点数的表示与运算

## 3.1. 浮点数的表示

1. 浮点数的表示格式
    $$
    N=r^{E}\times M
    $$
    - r: 阶码的底(隐含), =尾数的基数, 通常=2
    - E: 定点数: 阶码
    - M: 定点数: 尾数
    ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-28-18-02-04.png)
2. 规格化浮点数
   - 保证尾数最高位是一个有效值(非 0 )
   - 分类
     - 左规
     - 右规
   - 标准
     - $1/r\leqslant |M|\leqslant 1$
       - 原码
         - 正数
           - `0.1xxxxx`, ($1/x\leqslant M\leqslant (1-2^{-n})$)
           - `0.111111`~`0.100000`
         - 负数
           - `1.1xxxxx`, ($-(1-2^{-n})\leqslant M\leqslant -1/2$)
           - `0.100000`~`0.111111`
       - 补码
         - 正数
           - `0.1xxxxx`, ($1/x\leqslant M\leqslant (1-2^{-n})$)
           - `0.111111`~`0.000000`
         - 负数
           - `1.0xxxxx`, ($-1\leqslant M\leqslant -(1/2+2^{-n})$)
           - `1.000000`~`1.011111`
3. 浮点数的表示范围
4. IEEE 754 标准
    <img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-30-14-35-04.png" width=400px/>
    ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-30-14-35-25.png)
    - 尾码
      - 原码-->最高位总是1-->将其隐含-->尾数数值就多一位(23-->24)
        - 短浮点数&长浮点数
          - $(12)_{10}=(1100)_{2}\rightarrow 1.1\times 2^{3}\Rightarrow\text{整数部分}1不存在23\text{位尾数内}.$
        - 临时浮点数(扩展精度浮点数)
          - 无隐含位
    - 阶码
      - 移码
        - 短浮点 (偏移127)
          - $(-1)^s\times 1.M\times 2^{E-127}.$
        - 长浮点 (偏移1023)
          - $(-1)^{s}\times 1.M\times 2^{E-1023}.$
        - ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-30-16-47-13.png)
5. 定点.浮点
   1. 数值范围  
      浮点大
   2. 精度  
      定点高
   3. 数的运算  
      浮点复杂
   4. 溢出问题  
      1. 定点: 运算结果超出表示范围
      2. 浮点: 规格化后阶码超出表示范围

## 3.2. 浮点数的加减运算

<img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-30-16-56-08.png" width="700px"/>
<img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-30-16-58-55.png" width="700px"/>
<img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-30-17-02-18.png" width="700px"/>

# 4. 算数逻辑单元(ALU)

## 4.1. 串行加法器和并行加法器

- 根据组成加法器的全加器的个数

### 4.1.1. 一位全加器 FA



|[全加器](https://www.wolai.com/swithun/41R6NGwoJqmrMX8xDUrEzN#2YkvWMV1hVhGMDqxbU8EYB)|||
|-|-|-|
|和|奇数个1→$S_{i}=1$|$S_{i}=A_{i}\oplus B_{i}\oplus C_{i}$  
|进位|至少两个1<br />$A_iB_i$ : 相同两个1<br />$(A_{i}\oplus B_{i})C_{i-1}$: 有一个1加上进位|$C_{i}=A_{i}B_{i}+(A_{i}\oplus B_{i})C_{i-1}$
||进位(生成)信号g|$A_iB_i$|
||进位传递信号p|$A_i\oplus B_i$

逻辑电路||
-----|-----|-----
组合逻辑✔|无记忆性|
时序逻辑|当前状态+输入=输出|


### 4.1.2. 串行加法器

[逻辑符号](https://www.wolai.com/swithun/41R6NGwoJqmrMX8xDUrEzN#kFmV9uC9LHu7rUKQw8P43t)

||[串行加法器](https://www.wolai.com/swithun/41R6NGwoJqmrMX8xDUrEzN#5dWtoxufybH7EuSmbXoyP9)|
|-|-|
|加法器|一个|n个|
|n位操作数|加法n次|
|特点|$C_i\xrightarrow{进位触发器}C_{i-1}$
||数据串行送入,结果串行送回寄存器|
|速度|慢(主:$t_{产生进位}$ 次:$t_{求和延迟}$)

||[并行加法器(并行进位/先行进位/同时进位)](https://www.wolai.com/swithun/41R6NGwoJqmrMX8xDUrEzN#nnzUUaAoAgw2Nrrrkp9g8t)||||
|-|-|-|-|-|
|[公式](https://www.wolai.com/swithun/41R6NGwoJqmrMX8xDUrEzN#qCZUzZf4RFLMCfB4at4Hb3)||
|分类|[单级](https://www.wolai.com/swithun/41R6NGwoJqmrMX8xDUrEzN#eMfEhoCsvSsadB2EXTBADf)|组内并行|
|||组间串行||
||[n级](https://www.wolai.com/swithun/41R6NGwoJqmrMX8xDUrEzN#jph75tB8ewHNSX6taJzcHH)|组内并行|74181(4位)| BCLA( 成组先行进位电路)|
|||组间并行|74182(4位)


BCLA:

## 算数逻辑单元的功能和结构

<img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-30-18-27-46.png" width="600px"/>

- M: 算数/逻辑运算
- S: 运算种类

<img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-30-18-30-39.png" width="700px"/>

(SN74812: 先行进位芯片)

# 小结

## 为什么计算机采用二进制表示数据

`1 - 1.5`

## 二进制精确表示的数

- 整数可以
- 小数
  -$只能(\cfrac{1}{2^{n}})组合\rightarrow\text{无限逼近}$

## 浮点数和定点数の表示范围和精度

- 浮点数
  - 范围大
- 定点数
  - 精度高

## 移码表示浮点数的阶码的好处

1. 浮点数加减--比较阶码大小, 移码更方便
2. 检验移码の特殊值(0和max)容易
   1. `0` : $\lim\limits_{\text{指数}\rightarrow -\infty}\rightarrow\text{值}\sim 0$ ( 当尾数为0, 可以表示0 ; 不为 0 表示为正规化的数)
   2. `max`: $\lim\limits_{\text{指数}\rightarrow +\infty}$ ( 指数为零$\rightarrow$ 超出表示范围($\pm \infty$); 不为 0 $\rightarrow$ 运算错误 )

## 如何表示一个数值数据(都是二进制吗)

1. 二进制
   1. 无符号数
   2. 有符号数
      1. 定点数-->整数
      2. 浮点数-->实数
2. 十进制(二进制编码)
   1. 8431码(NBCD码)-->整数

## unsigned/short/int/long/float/double

- unsigned
  - 无符号定点整数
  - 补码
  - 寄存器位数不够时, 保留高n位( 可能溢出 )
- int
  - 定点整数
  - 补码
  - 32位/16位
- long
  - 定点整数(长整型)
  - 补码
- short
  - 定点整数(短整型)
  - 补码
- float
  - 浮点数(现在计算机: IEEE 754)

## 位数相同的定点数和浮点数课表示的数个数

- 一样多
  - 个数取决于编码的位数
    - $2^{n}$

## 浮点数如何舍入(IEEE 754)

- 原则:
  - 尽量误差范围对称, 平局误差为 0 (有舍有入)
  - 方法简单-->加快速度
- IEEE 754
  - ![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-31-16-46-13.png)

## 原码加减运算

- IEEE 754: 尾码->原码
- 原码加减实现
  - 转为补码
  - 直接计算, 符号和数值分开

## 定点数范围

![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-31-16-58-09.png)

## 浮点数范围

- 阶码 K+1 (1位阶符)
- 尾数 n+1 (1位数符)

![](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/2020-05-31-17-01-34.png)


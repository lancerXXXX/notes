---
title: 数据的表示与运算
index_img: /post_index_img/
date: 2020-05-27 13:11:14
categories:
    - 计算机组成
tags:
    - 计算机组成
---

# 1. 数制与编码

## 1.1. 进位计数制及其相互转换

1. 进位计数法
2. 进制转换
   1. 二-->八,十六
      ![image-20200527132700461](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527132700461.png)
   2. 十-->二/八   (基数乘除法)
      1. 除基取余法
         ![image-20200527132804232](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527132804232.png)
      2. 乘基取整法
         ![image-20200527132820341](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527132820341.png)

## 1.2. 真值和机器数

真值: 机器数代表的实际值
机器数: 符号"数字化"的数

## 1.3. BCD码

二进制编码的十进制数(Binary-Coded Decimal, BCD)  
四位二进制数$\overset{表示}{\rightarrow}$0-9

1. $8421$码
   1. $>9\rightarrow+6$进位修正
      ![image-20200527135521518](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527135521518.png)
2. 余三码
   1. $8421+(0011)_{2}$
3. $2421$码

## 1.4. 字符&字符串

1. 字符编码`ASCII`码
   1. 7位(10数+52字母+专用符号=128)

## 1.5. 校验码

增加冗余码, 检验或者纠错编码  

**码距**: 任意两个合法码字之间最少变化的二进制位数, 码距大于2-->检错能力(>=纠错能力)

### 1.5.1. 奇偶校验码

码距: 2
检测: 奇数位错误
纠正: none 

校验码中"1"的个数
<img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527143628328.png" alt="image-20200527143628328" style="zoom:80%;" />

### 1.5.2. 海明(汉明)校验码

码距: 大于2
检测: 一位数据错误
纠正: 一位数据错误

- $2^k\geqslant n+k+1$
  - 发现一位错
  - 纠正一位错
- $2^{k-1}\geqslant n+k$
  - 发现两位错
  - 纠正一位错

全校验位: 对所有进行偶校验

![image-20200527145716728](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527145716728.png)

### 1.5.3. 循环冗余校验(CRC)码/(N,K)码

<img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527145940212.png" alt="image-20200527145940212" style="zoom:80%;" />

- 原理: 线性编码理论
  - 适当多项式$G(x)$
  - $M(x)$长度确定
    - 余数$\Leftrightarrow$`CRC`码出错位
  - 检错: 接收$CRC$与$G(x)$相除
    - 余数$=0\rightarrow$正确
    - 余数$\neq 0$有错
      - $G(x)$选的好$\rightarrow$判断出错位
- 检测: 一位 || 多位(与多项式的选取有关)
- 适用: 计算机网络的数据链路层, 大量数据的数据校验	

![image-20200527150442058](%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20200527150442058.png)

## 1.6. 相关

## 1.7. 大小端

1. 高字节低字节

如`int a=16777220`，化为十六进制是`0x01 00 00 04`则`04`属于低字节，01属于高字节

2. 大小端模式
   （1）如果a在内存中的存放顺序为下图（即低字节存放在高地址），则为大端模式
   <img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/20180923183740810" alt="img" style="zoom:50%;" />
   （2）如果a在内存中的存放顺序为下图（即低字节存放在低地址），则为小端模式
   <img src="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/20180923183653465" alt="img" style="zoom:50%;" />
   (指针在低地址 0x001)

# 定点数的表示与运算

## 原码

- 纯小数
$$
[x]_{\text{原}}=\begin{cases}
   x & ,1>x\geqslant 0 \\
   1-x=1+|x| & ,0\geqslant x>-1
\end{cases}
$$
- 纯整数
$$
[x]_{\text{原}}=\begin{cases}
   0,x & , 2^{n}>x\geqslant 0 \\
   2^{n}-x=2^{n}+|x| & ,0\geqslant x>-2^{n}
\end{cases}
$$

## 补码

- 纯小数
$$
[x]_{\text{补}}=\begin{cases}
   x & ,1>x\geqslant 0 \\
   2+x=2-|x| & ,0>x\geqslant -1
\end{cases}(\mod 2)
$$
- 纯整数
$$
[x]_{\text{补}}=\begin{cases}
   0,x & ,2^{n}>x\geqslant 0 \\
   2^{n+1}+x=2^{n+1}-|x| & ,0\geqslant x\geqslant -2^{n}
\end{cases}(\mod 2^{n+1})
$$
- 原码求补码
  - 正数: $[x]_{\text{补}}=[x]_{\text{原}}$
  - 负数: 取反加一
- 补码算数位移
  - $[x]_{\text{补}}\text{符号位}\&\text{数值位}\rightarrow\text{右移}\&\text{保持符号位值不变}\rightarrow\text{除法功能}$
- 变形补码
  - $$
    [x]_{\text{补}}=\begin{cases}
       x & ,1>x>0 \\
       4+x=4-|x| & ,0>x\geqslant -1
    \end{cases}(\mod 4)
    $$
   - ALU部件--00正,11负
## 反码

- 纯小数
$$
[x]_{\text{反}}=
\begin{cases}
   x & ,1>x\geqslant 0 \\
   (2-2^{-n})+x & ,0\geqslant x>-1
\end{cases}(\mod 2-2^{-n})
$$
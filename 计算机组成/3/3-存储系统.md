---
title: 3-存储系统
index_img: /post_index_img/
date: 2020-05-31 17:02:46
categories:
    - 计算机组成
tags:
    - 计算机组成
---

# 1. 概述

## 1.1. 分类

### 1.1.1. 按 计算机中的作用(层次)分类

1. 主存储器
   1. 存放
      1. 大量程序和数据
   2. 访问
      1. CPU随时随地访问
   3. 交换数据
      1. Cache
      2. 辅助存储器
   4. 特点
      1. 容量小
      2. 存取速度较快
      3. 价格较高
2. 辅助存储器
   1. 存放
      1. 当前暂时不用的程序和数据,永久性保存的信息
   2. 访问
      1. CPU不能
   3. 特点
      1. 容量极大
      2. 存取速度较慢
      3. 单位成本底
3. 高速缓冲存储器
   1. 存放
      1. 正在执行的程序段和数据
   2. 访问
      1. CPU高速使用
   3. 特点
      1. 容量小
      2. 速度和CPU速度相匹配
      3. 价格高

### 1.1.2. 按 存储介质 分类

- 磁表面存储器
  - 磁盘
  - 磁带
- 磁芯存储器半导体存储器
  - MOS型存储器
  - 双极型存储器
- 光存储器
  - 光盘

### 1.1.3. 按 存取方式 分类

- 随机存储器(RAM)
  - 特点
    - 任意单元内容随机存取
  - 时间
    - 存储单元的物理位置
  - 应用
    - 主存
    - 高速缓冲存储器
  - 分类
    - 静态RAM(触发器)
    - 动态RAM(电容充电)
  - 优点
    - 读写方便
    - 使用灵活
- 只读存储器(ROM)
  - 特点
    - 只能随机读出不能写入
    - 断电不消失
  - 应用
    - 固定不变的程序,常数,汉字字库
    - 操作系统的固化
    - (ROM+RAM)->构成主存的存储域
  - 分类
    - 不可反复重写
    - 可反复重写
      - 电擦除等
        - 写入速度慢
- 串行访问存储器
  - 特点
    - 按其物理地址先后顺序寻址
  - 分类
    - 顺序存取存储器(磁带)
      - 必按顺序存取
      - 时间
        - 存储器上的物理位置
        - 慢
    - 直接存取存储器(磁盘)
      - 先找小区域->再顺序查找

### 1.1.4. 按 信息的可保存性 分类

- 易失性存储器
  - 如
    - RAM
- 非易失性存储器
  - 如
    - ROM
    - 磁表面存储器
    - 光存储器
- 破坏性读出
  - 原存储信息被破坏
  - 必须
    - 紧接一个再生操作->恢复信息
- 非破坏性读出

## 1.2. 存储器性能指标


|存储容量|$\text{存储字数}\times字长(1M\times 8位)$|
|-|-|
| 单位成本|$\text{每位价格}=\text{总成本}/\text{总容量}$|
| 存储速度|$\text{数据传输率}=\text{数据的宽度}/\text{存储周期}$|
|主存带宽($B_{m}$)(数据传输率)|每秒从主存进出的最大数量 $=\frac{传输数据}{}$|
|| 单位:字/s,字节/s,位/s|

- 存取时间($T_{a}$)
  - 启动一次存储器~完成该操作
  - 分类
    - 读出时间
    - 写入时间
- 存取周期($T_{m}$)
  - 存储器完整读写操作
    - 连续两次独立访问存储器操作(读/写)间隔
  - 等于
    - $T_{a}$+( 内部状态的复原时间)
      - 破坏性读出存储器
        - $T_{m}>>T_{a}\rightarrow T_{m}=2T_{a}$

![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-09-13-19-10-51.png)

# 2. 层次化结构

## 2.1. 多级存储系统

|多级存储器结构| <img src="3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-09-13-20-56-32.png" width="300px"/>
|-|-|

|三级存储系统的层次结构及其构成|<img src="3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-09-13-20-55-57.png" width="500px"/>|||
|-|-|-|-|
||**Cache-主存**|**主存-辅存**||
|解决|CPU和主存速度不匹配|存储系统容量|
|数据调动实现|硬件自动完成|硬件: 地址翻译<br />操作系统: 资源管理||
|| 对程序员透明| 对系统程序员不透明→资源管理||
|扩展|| 虚拟存储系统|编程的地址⇔虚拟存储器的地址空间|
|||| 编程可用空间远大于主存空间|

|CPU同时访问内存和Cache|<img src="3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-09-13-20-47-08.png" width="600px"/>|
|-|-|

# 3. 半导体随机存储器

![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-09-13-19-01-27.png)

## 3.1. SRAM和DRAM

$$
\text{存储体}\left\{\begin{matrix}
\overbrace{\text{存储单元}}^{\text{若干}}\left\{\begin{matrix}
\overbrace{\text{存储元}}^{\text{多个地址码相同的}}: \text{存放一个二进制位的物理器件}
\end{matrix}\right.
\end{matrix}\right.
$$

<html>
<table>
<tr>
<td>

### 3.1.1. SRAM


- 存储元
  - 组成
    - 双稳态触发器(六晶体管MOS)
      - 非破坏性读出
- 特点
  - 读取速度块
  - 集成度低
  - 功耗大
- 应用
  - 高速缓冲存储器

</td>
<td>

### 3.1.2. DRAM

- 存储原理
  - 存储元电路中栅极电容上的电荷
  - 维持($1\sim 2ms$)
    - 刷新周期($2ms$)
      - 集中刷新
        - 方式
          - 固定时间
          - 存储所有行逐一再生
          - 停止读写操作
            - 死时间(死区)
        - 优点
          - 读写操作不受刷新工作影响$\rightarrow$存取速度较高
        - 缺点
          - 死区不能访问
      - 分散刷新
        - 方式
          - 工作周期划分
            - 前半
              - 读写
            - 后半
              - 刷新某一行
        - 优点
          - 没有死区
        - 缺点
          - 存取周期长
          - 整机速度降低
        - 发展
          - 透明刷新
            - 刷新安排在存储器的译码阶段
      - 异步刷新
        - 前两种结合
        - 方式
          - 时间间隔 $t$ : 刷新周期/行数
        - 优点
          - 避免CPU等待时间过长
          - 减少刷新次数
          - (根本上)提高整机效率
    - 特点
      - 对CPU透明$\rightarrow$刷新不依赖外部的访问
      - 动态RAM刷线代为是行$\rightarrow$刷新操作需要行地址
      - 类似读操作
        - 不同
          - 仅给栅极电容补充电荷,不需要信息输出
          - 不需要选片(整个存储器中的所有芯片同时被刷新)
      - 和易失性存储器概念不同
        - SRAM和DRAM都断电内容消失
        - 只DRAM需要刷新
- 存储元
  - 通常一个晶体管
- 特点
  - 比SRAM密度高(存储元通常一个晶体管)
  - 地址线是原来的$\frac{1}{2}$(地址复用技术)
  - 地址信号分行列两次传送
  - 读取速度相对慢
  - 容易集成
  - 位价低
  - 容量大
  - 低功耗
- 应用
  - 大容量主存系统

</td>
</tr>
</table>
</html>


### 3.1.3. 存储器的读写周期

#### 3.1.3.1. RAM读周期

<img src="3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-01-17-34-19.png" width="600px"/>

- $t_{A}:\quad\text{读出时间}$
  - 给出有效地址\~读出单元内容\~外部数据总线稳定出现
- $\overline{CS}:\quad \text{地址片选信号}$
  - $\overset{\text{保持到}}{\rightarrow}\text{数据稳定输出}$
- $t_{CO}:\quad\text{片选的保持时间}$
  - $\overline{WE}\overset{\text{读周期}}{\rightarrow}\text{高电平}$
- $t_{RC}:\qquad \text{读周期时间}$

#### 3.1.3.2. RAM写周期

<img src="3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-01-17-50-10.png" width="500px"/>

- $t_{W}:\quad \text{保证数据总线上的信息能可靠写入存储器}$
  - $\overline{CS},\overline{WE}\text{相与最小宽度}$
- $\overline{WE}$
  - 低电平
- $t_{WC}:\quad \text{地址有效时间}$
  - $\text{至少}=t_{AW}+t_{W}+t_{WR}$
- $t_{DW}$
  - 写入数据在此之前在数据总线上稳定

### 3.1.4. 比较

<img src="3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-01-19-05-32.png" width="700px"/>

## 3.2. 只读存储器(ROM)

### 3.2.1. 特点

- ROM,RAM都随机存取
- SRAM,DRAM都 易失性半导体存储器
- ROM特点
  - 结构简单$\rightarrow$位密度$>$可读写存储器
  - 非易失性$\rightarrow$可靠性高

### 3.2.2. ROM的类型

- 制造工艺
  - MROM(掩模式)
    - 特点
      - 生产过程写入
      - 无法改变
    - 优点
      - 可靠性高
      - 集成度高
      - 价格便宜
    - 缺点
      - 灵活性差
  - PROM(一次可编程只读存储器)
    - 特点
      - 用户编程器写入
      - 无法改变
  - EPROM(可擦除只读存储器)
    - 特点
      - 用户编程器写入
      - 可以多次改写
        - 写入时间过长, 变成次数有限$\rightarrow$不能取代RAM
    - 分类
      - UVEPROM(紫外线擦除)
      - $E^2PROM$(电擦除)
    - 优点
      - 价格便宜
      - 集成度高
  - Flash Memory(闪存存储器)
    - 发展基础
      - EPROM和$E^2PROM$
    - 特点
      - 不加电长期保存
      - 在线快速擦除与重写
  - Solid State Drives(固态硬盘)
    - 发展基础
      - Flash Memory
    - 组成
      - 控制单元
      - 存储单元(FLASH芯片)
    - 特点
      - 不加电长期保存
      - 在线快速擦除与重写
      - 对比传统硬盘
        - 读写速度快
        - 低功耗
        - 缺点
          - 价格较高

## 3.3. 主存储器的基本组成

![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-02-13-26-09.png)

> $\text{容量}: 2^{36}\times 64\text{位}$

- **存储器**
  - 核心
    - **存储矩阵**(**存储体**)
      - **记忆单元**(**存储单元**)
        - 具有两种稳态表示01的物理器件
      - 信息存取
        - 编址(对存储单元编号)
          - **编址单位**
            - 具有相同地址的 存储元件 构成的一个单位 : **存储字**
              - 按字节编址(现代计算机)--一个地址有1字节
              - 按字编址

1. 访问过程
   1. $$
      \text{被访问单元}
      (\text{主存地址})\overset{CPU}{\rightarrow}
      MAR
      \begin{cases}
         \overset{\text{地址线}(\text{单向})}{\rightarrow}
         \text{地址寄存器}\\
         \begin{cases}
            \text{读} & , 
            \begin{cases}
               \text{读信号}\overset{\text{控制线}}{\rightarrow} \text{读写控制电路} & \\
                \text{读出的内容}\overset{\text{数据线}}{\rightarrow}MDR & 
            \end{cases}\\
            \text{写} & ,
            \begin{cases}
               \text{写信号}\overset{\text{控制线}}{\rightarrow}\text{读写控制电路}&  \\
               \text{要写的信息}\overset{CPU}{\rightarrow} MDR\overset{\text{数据线}(\text{双向})}{\rightarrow}\text{写入选中的单元}&
            \end{cases}
         \end{cases}
      \end{cases}
      $$

# 4. 主存储器与CPU的连接

## 4.1. 连接原理

![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-02-14-28-07.png)

1. $\text{数据传输率}\overset{\text{正比}}{\rightarrow}\text{数据总线位数}\times\text{工作频率}$

## 4.2. 主存容量的扩展

### 4.2.1. 位扩展法

- 使 数据位数 CPU的数据线数 相等

![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-02-14-32-58.png)

- $8K\times 1\text{位}\rightarrow 8K\times 8\text{位}$
- $\overline{CS},\overline{WE}\text{连到一起}$

### 4.2.2. 字扩展法

![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-02-15-20-25.png)

![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-02-15-21-04.png)

## 4.3. 字位同时扩展

![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-02-15-24-37.png)

## 4.4. 存储芯片的地址分配和片选

1. CPU访问存储单元
   1. 步骤
      1. **片选**(选择存储芯片)
         1. 实现方式
            1. **线选法**
               1. 高地址线分别接至 各个存储器的 片选端
               2. "0"$\overset{}{\rightarrow}$选中
               3. ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-02-16-08-30.png)
               4. 优点
                  1. 不需要地址译码器,线路简单
               5. 缺点
                  1. 地址空间不连续
                  2. 选片的地址线必须分时位低电平(否则不工作)
                  3. 不能充分利用系统存储空间, 地址资源浪费
            2. **译码片选法**
               1. 高位地址$\overset{\text{地址译码器}}{\rightarrow}$片选信号
      2. **字选**(选中的芯片依地址码选择响应的存储单元)
         1. 功能
            1. 数据的存取
         2. 实现方式
            1. CPU送出的N条地位地址线

## 4.5. 存储器与CPU连接

1. 存储芯片 选择
   1. 类型(ROM/RAM)
      1. ROM
         1. 存放
            1. 系统程序
            2. 标准子程序
            3. 各类常数
      2. RAM
            1. 用户编程
   2. 数量
      1. 同时
         1. 连线尽量简单,方便
2. 地址线 选择
   1. 字选
      1. CPU地址线地位
         1. 译码
            1. 芯片的片内逻辑
      2. CPU地址线高位
         1. 译码
            1. 外接译码器
3. 数据线 的 连接
   1. CPU的数据线数与存储线片的数据线数
      1. 相等
         1. 直接相连
      2. 不相等
         1. 对存储芯片扩位
4. 读/写命令线
   1. 分类
      1. 一条
         1. 高电平读
         2. 低电平写
      2. 两条 (低电平有效)
         1. 读 $\overline{RD}$
            1. 连接存储芯片允许读控制端
         2. 写 $\overline{WE}$
            1. 连接存储芯片允许写控制端
5. 片选线
   1. 选片
      1. 取决于
         1. $\overline{CS}$能否收到 片选有效信号
            1. 片选有效信号
               1. 相关
                  1. $\overline{MREQ}$:CPU的访存控制信号(底)
                     1. 访问IO,(高),不要求存储器工作

# 5. 双端口RAM和多模块存储器

## 5.1. 双端口RAM

![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-02-17-10-36.png)

1. 数据冲突
   1. 错误种类
      1. 无错误
         1. 不同时 同一地址存取
         2. 同时 同一地址读
      2. 写入错误
         1. 同时 同一地址写
      3. 读出错误
         1. 同时 同一地址 一个写 一个读
   2. 解决
      1. $\overline{BUSY}$ "忙"信号置为零
         1. 延迟访问

## 5.2. 多模块存储器

1. 作用
   1. 提高访存速度
2. 分类
   1. **单体多字存储器**
      1. 特点
         1. 一个存储体
         2. 一个存储单元m个字
         3. 总线宽度m个字
         4. 地址顺序排列&处于同一存储单元
      2. 存取方式
         1. 一个存取周期, 同一地址取出m条指令
         2. 每隔 1/m 存取周期, CPU向主存取一条指令
      3. 优点
         1. 增加 存储器带宽
         2. 提高单体存储器 运行速度
      4. 缺点
         1. 指令和数据在主存必须连续存放
            1. 否则 效果不明显
               1. 例如
                  1. 转移指令
                  2. 操作数不连续存放
   2. **多体并行存储器**
      1. 特点
         1. 各模块独立读写控制电路,地址寄存器,数据寄存器
         2. 并行工作/交叉工作
      2. 分类
         1. **高位交叉编址**
            1. 不能提高存储器的吞吐率(仍是**顺序存储器**)
               1. CPU总是顺序访问存储模块
                  1. 访问连续主存块
                     1. 现在一个模块内访问
                     2. 完后访问下一个
               2. 存储模块不能被并行访问
            2. <img src="3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-02-17-39-48.png" width="800px"/>
         2. **低位交叉编址**
            1. 模块按照模m交叉编址
               1. 模块号 = 单元地址 % m
                  1. $M_0: 0,m,\cdots,(k-1)m单元$
            2. ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-03-14-15-16.png)
            3. ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-03-14-34-38.png)
               1. 存储器交叉模块数应
                  1. $\geqslant m=T/r$
                  2. T: 模块存取一个字周期
                  3. r: 总线传输周期
                  4. 存取m个字
                     1. $t_1=T+(m-1)r$

# 6. 高速缓冲存储器

- 单纯依靠并行主存$\overset{}{\rightarrow}$提高主存系统的频宽有限
  - 程序的转移概率不会很低
  - 数据分布的离散型较大
  - 因此
    - 从系统结构上改进
      - **存储体系**
        - Cache-主存 层次
        - 主存-辅存 层次

## 6.1. 程序访问的局部性原理

1. 程序访问的局部性
   1. 分类
      1. 时间局部性
         1. 程序存在循环
            1. 未来用的很可能是现在用的
      2. 空间局部性
         1. 指令通常顺序存放,执行
         2. 数据一般簇聚存储(向量,数组)
            1. 未来用的很可能存储空间临近
   2. 应用
      1. **高速缓冲技术**
         1. 正在使用的部分$\overset{\text{放入}}{\rightarrow}$Cache

## 6.2. Cache的基本工作原理

![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-03-15-22-24.png)

1. 构成
   1. SRAM
2. 划分
   1. Cache & 主存 $\overset{\text{相等}}{\rightarrow}$块
   2. Cache块(行)
      1. 组成
         1. 若干字节
      2. 块长(Cache行长)
3. 过程
   1. 读
      1. CPU发出读请求
      2. Cache命中$\overset{\text{转换}}{\rightarrow}$Cache地址
      3. 不命中$\overset{}{\rightarrow}$访问主存 & 此字所在块一并存入Cache(可能替换)
         1. 硬件完成
      4. 特殊
         1. Cache和内存同时访问
            1. Cache访问到了就停止对内存的访问
   2. 写
      1. Cache和内存种的内容不一致
         1. 写策略问题
            1. 全写法
            2. 写回法
4. 交换单位
   1. CPU-Cache: 字
   2. Cache-主存: 块
5. 命中率
   1. $H=N_{c}/(N_{c}+N_{m})$
   2. $T_{a}=Ht_{c}+(1-H)t_{m}$
      1. $t_{m}: \text{未命中访问时间}$

## 6.3. Cache和主存的映射方式

### 6.3.1. 直接映射

1. 关系
   1. $j=i\mod 2^{c}$
      1. j: Cache块号/行号
      2. i: 主存的块号
      3. $2^{c}$: Cache总块数
2. 优点
   1. 实现简单
3. 缺点
   1. 不够灵活
   2. 块冲突率最高
   3. 空间利用率最低
4. <img src="3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-03-17-16-05.png" width="400px"/>
5. <img src="3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-03-17-16-45.png" width="700px"/>
6. 过程
   1. c位$\overset{}{\rightarrow}$Cache行
   2. 比较 Cache行中的标记$\overset{}{\rightarrow}$t位标记
      1. 相等&&有效位=1 $\overset{}{\rightarrow}$命中
      2. 否则
         1. 不命中
            1. CPU从内存读信息$\overset{}{\rightarrow}$Cache行
            2. &&有效位=1
            3. &&标记=地址中的高t位
            4. &&内容$\overset{}{\rightarrow}$CPU
7. 例子
   1. 数据Cache: 8个Cache行, 行长64B (主存空间大小256MB)
   2. ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-05-15-35-00.png)
   3. 主存地址: 28位($256MB=2^{8}B$)
      1. 块内地址: 6位($2^{6}=64B$)
      2. 行号: 3位($2^{3}=8$)
      3. 标记: 19位=28-6-3
      4. ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-05-15-43-55.png)
   4. Cache总容量: 8x(1+19+512)=4356位
   5. 主存块对应Cache行号 (主存地址3200(十))
      1. 直接映射
         1. 字块号: 50 (3200B/64B)
         2. 对应Cache行号: 2 (50 mod 8)
      2. 二路组相联
         1. 对应Cache组号: 2 (50 mod 4)
         2. 对应Cache行号: 4 或 5
   6. 访存过程 (地址0123456H)
      1. $\underbrace{0000\ 0001\ 0010\ 0011\ 010}_{\text{标记位}}\underbrace{0\ 01}_{\text{块号}}\underbrace{01\ 0110}_{\text{块内地址}}$

### 6.3.2. 全相联映射

1. <img src="3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-03-18-19-31.png" width="700px"/>
2. <img src="3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-03-18-24-06.png" width="400px"/>
3. 特点
   1. 需要比较所有标记
4. 优点
   1. 比较灵活
   2. 冲突概率低
   3. 空间利用率高
   4. 命中率高
5. 缺点
   1. 标记比较速度慢
   2. 实现成本较高
      1. 相联存储器$\overset{}{\rightarrow}$地址映射
         1. 昂贵

### 6.3.3. 组相联映射

- 特点
  - 组间-直接映射
  - 组内-全相联映射
    - 路数:每组Cache行的数量越大-->冲突概率越低
- 映射关系
  - ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-05-15-14-05.png)
- 映射方式
  - ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-05-15-14-38.png)
- 访问过程
  - 地址中间组号-->Cache组
  - 比较 地址高位标记&&每个行标记
    - 有一个相等&&有效位1
      - 命中
    - 都不相等||相等&&有效位0
      - 不命中
        - CPU读出内容到Cache组任意一个空闲行
        - 有效位1&&设置标记
        - &&该地址内容==>CPU

### 6.3.4. 对比

1. 命中率: 直接最低, 全相联最高
2. 判断开销,时间: 直接最小,短; 全相联最大, 长
3. 标间所占额外空间: 直接最小, 全相联最大

## 6.4. Cache主存块的替换算法

### 6.4.1. 随机算法(RAND)

- 原理
  - 无
- 实现
  - 简单
- 命中率
  - 低

### 6.4.2. 先进先出(FIFO)

- 原理
  - 无
- 实现
  - 比较容易

### 6.4.3. 近期最少使用(LRU)

- 原理
  - 程序访问的局部性原理
- 算法
  - 堆栈类
- (平均)命中率
  - 高于FIFO

### 6.4.4. 最不经常使用算法

- 特点
  - 一段时间内访问次数最少的

## 6.5. Cache写策略

### 6.5.1. 写命中

#### 6.5.1.1. 全写法

1. 特点
   2. 同时 写 Cache和主存
2. 优点
   1. 实现简单
   2. 随时保证主存数据正确性
3. 缺点
   1. 增加访存次数
      1. 优化
         1. 写缓冲
            1. 用处: 减少写入主存的时间损耗
            2. ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-05-17-31-34.png)
            3. CPU同时写到Cache和写缓冲
            4. FIFO队列
               1. 可能问题
                  1. 写缓冲饱和溢出
   2. 降低Cache的效率

#### 6.5.1.2. 写回法

1. 特点
   1. 块换出时写回
   2. 加一个标志位(脏位)
2. 优点
   1. 减少访存次数
3. 缺点
   1. 不一致隐患

### 6.5.2. 写不命中

#### 6.5.2.1. 写分配法

1. 实现
   1. 主存块-->Cache
   2. 更新Cache块
2. 原理
   1. 试图利用程序的空间局部性
3. 缺点
   1. 每次不命中-->从主存读取一块

#### 6.5.2.2. 非写分配法

1. 实现
   1. 写入主存
2. 通常
   1. 和全写法合用

### 6.5.3. 多级Cache

- 通常
  - 三级
    - L1 Cahce
      - 指令Cache
      - 数据Cache
    - L2 Cache
    - L3 Cache
- 例
  - ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-05-18-01-46.png)
  - L1 对 L2 : 全写法
  - L2 对 主存: 写回法
    - L2 : 避免L1 频繁写-->写缓冲饱和溢出

# 虚拟存储器

- 特点
  - 主存&辅存 地址空间 统一编址
  - 用户在此自由编程
  - 实际物理存储层次上
    - 程序&数据 进入磁盘: 操作系统管理
    - 运行所需部分-->主存: 操作系统
- 概念
  - 虚地址(逻辑地址): 编程允许涉及的地址
  - 虚拟空间(程序空间): 虚地址对应的存储空间
  - 实地址(物理地址): 实际的主存单元地址
  - 主存地址空间: 实地址对应
- ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-05-18-06-57.png)
- 过程
  - 虚实地址关系: 辅助硬件
  - 判断是否在主存: 辅助硬件
    - 在
      - CPU直接访问: 地址变换
    - 不在
      - 调入主存: 所在的一页/一段
        - 若主存满: 替换算法: 一页/一段

## 页式虚拟存储器

- 概念
  - 实页: 主存的页
  - 虚页: 虚存的页
  - 页表: 虚拟地址-->物理地址
    - 存放在: 主存
    - 对照表: 虚实页号
      - 调入主存时分配的位置
      - 有效位(装入位)
        - 页在主存
          - 存放物理页号
        - 不在
          - 可以放该页磁盘地址
    - ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-05-18-27-03.png)
- 实现
  - 虚拟地址 分成
    - 虚页号
    - 页内地址
- 执行指令时
  - 虚拟地址-->主存物理地址
    - 页表基址寄存器(一个进程一个)
      - 该进程 页表首地址
        - 虚拟地址高位虚页号-->对应页表项
          - 装入位: 1
            - 取出物理页号
              - 拼接虚拟地址 页内地址-->物理地址
          - 装入位: 0 -->缺页
            - 缺页处理: 操作系统(缺页异常处理程序)
  - ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-05-18-27-23.png)
- 优点
  - 页表简单,调入方便: 页面长度固定
- 缺点
  - 浪费: 程序最后一段装不满一页
  - 不方便
    - 页不是逻辑上独立实体
    - 处理, 保护, 共享 方便性 都不如 段

## 加快地址转换: 块表(TLB)

1. 问题
   1. 页式虚拟存储增加访存次数
      1. 查页表
      2. 取数据
      3. 缺页: 页面替换/修改
2. 原理
   1. 程序执行的局部性原理
   2. 常用页$\overset{\text{放到}}{\rightarrow}$TLB
3. 相联方式
   1. 通常 全相联/组相联
4. ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-06-13-38-28.png)
5. ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-06-14-14-34.png)
6. ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-06-16-33-28.png)

## 段式虚拟存储器

1. 划分依据
   1. 程序逻辑结构
2. 概念
   1. 段表
      1. 逻辑段 在 主存中存放的位置
3. ![](3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/2020-06-06-16-43-02.png)
4. 优点
   1. 段的分界$\overset{\text{对应}}{\rightarrow}$程序的自然分界
   2. 逻辑独立性
      1. 易于
         1. 编译
         2. 管理
         3. 修改
         4. 保护
         5. 多道程序的共享
      2. 缺点
         1. 段长度可变
         2. 分配长度不便
         3. 容易留下碎片,不好利用,造成浪费

## 段页式虚拟存储器

1. 划分方式
   1. 段(必须是页的整数倍): 对应一个段表
      1. 页(调入调出基本单位): 对应一个页表
2. 地址划分
   1. 段号
   2. 段内页号
   3. 页内地址
3. 过程
   1. 段号
      1. 段表地址
   2. 段内页号
      1. 段表-->页表起始地址+段内页号==页表地址
   3. 页内地址
      1. 页表-->实页号+页内地址==主存实地址
4. 优点
   1. 兼具页式段式优点
      1. 按段实现 共享 和 保护
5. 缺点
   1. 地址变换中两次查表-->系统开销大

## 虚拟存储器与Cache

1. 共同
   1. 目标: 提高系统性能
   2. 梯度: 容量, 速度, 价格
   3. 数据划分: 小信息块-->基本传递单位(Cache更大)
   4. 策略: 地址映射,替换算法,更新策略
   5. 思想: "快速缓存": 局部性原理
2. 不同
   1. 解决: Cache(系统速度), 虚拟存储器(主存容量)
   2. 实现: Cache(硬件,所有透明), 虚存(OS和硬件, 系统程序员不透明, 应用程序员透明)
   3. 不命中性能影响: Cache(Cpu 10倍),硬盘(主存 100倍)-->虚存系统不命中影响大
   4. CPU通信
      1. Cache不命中 --> 主存CPU直接通信
      2. 虚存不命中 --> 先调入主存
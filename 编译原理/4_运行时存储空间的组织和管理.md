---
title: 4_运行时存储空间的组织和管理
index_img: /post_index_img/编译原理.jpg
date: 2020-01-13 16:53:24
categories:
    - 编译原理
tags:
    - 编译原理
---

# 1. 运行时存储空间的组织和管理

1. 通常的命令式编程语言
   1. 表现: 多个函数的实现和相互调用
   2. 入口函数-`mian()`
   3. 代码执行过程-依据过程调用关系形成一个(调用结构图)
   4. 辅助(存储空间)-每个过程的执行
      1. 过程的代码- 需要一定存储空间
      2. 过程中的局部变量-需要存储空间暂存
2. 词法,语法,语义分析后
   1. 生成目标代码前
      1. 程序的**静态正文**&实现这个程序的**运行时的活动**  联系起来
         1. 弄清楚 将来在 代码运行时刻
            1. 代码中的各种(变量,常量,等用户定义的量)如何存放,如何访问
3. 程序的执行过程中
   1. 程序中数据的存取 通过 与之对应的存储单元来进行的
4. 存储单元表示--标识符
   1. 对应的内存地址由编译程序或由其生成的目标程序运行时进行分配

## 1.1. 过程的活动 (概念一)

- 过程的一次执行--过程的一次活动

## 1.2. 活动记录 (概念二)

- 过程活动时存放所需信息的存储空间

## 1.3. 活动的生存期

- 过程P一次活动的生存期
  - 从执行该过程第一步操作--最后一步操作之间的操作时间
- 过程可以时递归的
- 一个过程可对应多个活动

## 1.4. 影响存储分配策略的语言特征

1. 过程 能否 递归
2. 局部变量的值是否保留: 当控制从过程的活动返回时
3. 过程 能否 访问非局部变量
4. 过程 调用的参数传递方式
5. 过程能否作为参数被传递
6. 过程能否作为结果值传递
7. 存储块能否在程序控制下动态地分配
8. 存储块是否必须显式地释放

## 1.5. (过程内部)局部存储分配策略

### 1.5.1. 过程

1. 过程定义
   1. 是一个声明
   2. 最简形式: 一个名字(**过程名**)和一个语句(**过程体**)联系起来
   3. 返回值的过程: 函数
   4. 完整的程序也可以看作一个过程
2. 过程调用
      1. **被调用**: 过程名出现在调用语句中, 称在该点
      2. .this: 执行被调用过程 的 过程体
3. 形式参数
   1. 出现在过程调用中的某些名字
4. 实在参数
   1. 过程调用中的.this传递给被调用过程,取代过程体中的形参
5. 活动的生存期

### 1.5.2. 名字的作用域和绑定

1. 名字的作用域
   1. 一个名字在程序中出现时,改名字的哪个声明应用到这个出现
   2. 一个声明起作用的程序部分称为该声明的**作用域**
   3. 即使一个名字在程序中只声明一次，该名字在程序运行时也可能表示不同的数据对象
2. 名字（变量）的作用域和绑定
   1. 环境: 函数(将名字映射到存储单元)
   2. 状态: 函数(存储单元映射到它所保存的值)

<center>

```mermaid
graph LR
名字--环境-->存储单元--状态-->值
```
</center>

   1. 环境把名字映射到左值（存储单元），而状态把左值映射到右值（值）。
   2. 赋值改变状态，但不改变环境。 
   3. 如果环境将名字x映射到存储单元s，就说x被绑定到s。

### 1.5.3. 静态概念和动态概念的对应

| 静态概念     | 动态对应     |
| ------------ | ------------ |
| 过程的定义   | 过程的活动   |
| 名字的声明   | 名字的绑定   |
| 声明的作用域 | 绑定的生存期 |


### 1.5.4. 活动记录(帧)

1. 被编译程序每次运行时，编译器从操作系统获得一块存储区（内存）。其内容包括：
   1. 编译后的目标代码 (可执行程序 .exe)
   2. 数据对象 (各种静态变量和动态变量)
   3. 用于管理过程活动的控制栈 (活动记录 )


- 一般的活动记录的布局(各个域)
- 寄存器往往可以取代它们中的一个或多个域

<center>

| 域       | 用途                                 | 例                                                            |
| -------- | ------------------------------------ | ------------------------------------------------------------- |
| 临时数据 | 本过程计算中可能用到的临时变量       | 寄存器放不下表达式结果,可以放这                               |
| 局部数据 | 本过程内部定义的局部变量             |                                                               |
| 机器状态 | 用于保存本过程前的机器状态           | (典型)返回地址(程序计数器的值),要用的并且要恢复的寄存器的内容 |
| 访问链   | 用于引用存于其他活动记录的非局部数据 |                                                               |
| 控制链   | 指向 调用过程的指针                  |                                                               |
| 返回值   | 本过程返回给调用过程的值             | 也常常用寄存器返回-效率                                       |
| 实在参数 | 调用过程传递给本过程的参数           | 也常常用寄存器传参-效率                                       |

</center>

- 每个域的长度都可以在过程调用时确定
- 几乎所有域的长度可以在编译时确定
  - 例/外: 过程开始执行后才能确定大小的局部数组
    - 执行到过程调用时才能确定局部数据域的大小

### 1.5.5. 局部数据的布局

1. 最小单位:字节是可编址内存的.this。
2. 一个过程所声明的局部变量，按这些变量声明时出现的次序，在活动记录的局部数据区中依次分配空间。 
3. 局部数据的地址可以用相对于某个位置（本过程对应的活动记录的起始位置）的**偏移**来表示。
4. 数据对象的存储安排深受目标机器寻址方式的影响，存在**对齐**问题。例如，要求整数（int，long）的相对地址可以被4整除。
5. 由于对齐而引起的无用空间称为**衬垫空白区**。

### 1.5.6. 程序块

- 本身含有局部变量声明的语句
- 特点
  - 嵌套结构--程序块结构
    - 程序块中声明的作用域是按最接近的嵌套规则给出的
    - 编译器存储分配时,也为内嵌程序块声明的变量留出所需的空间

---------------
## 1.6. 三种存储分配方式


### 1.6.1. 运行时内存的划分

<center>

| 内存划分 | 存放                        | 对应         | 确定时间                                            |
| -------- | --------------------------- | ------------ | --------------------------------------------------- |
| 代码     | 目标代码(.exe)              |              | 编译时,运行时不会改变                               |
| 静态区   | 静态变量&外部变量(全局变量) | 静态分配策略 | 编译时,数据尽可能放这--</br>可编译到目标代码中,效率 |
| 堆       | 杂乱无章(动态分配的内存)    | 堆式分配策略 | 向高地址增长                                        |
| 空闲内存 |                             |              |                                                     |
| 栈       | 确定的(活动记录)            | 栈式分配策略 | 向低地增长                                          |

</center>


### 1.6.2. 静态分配策略

1. 名字在程序被**编译时**绑定到存储单元，不需要运行时的任何支持。
2. 绑定的生存期是**程序的整个运行时间**。
3. 控制再次进入该过程时，局部变量的值和控制上一次**离开时的一样**。
4. 每个活动**记录的大小是固定**的。
5. 过程调用时**保存信息的地址**在编译时也是**已知**的。

#### 1.6.2.1. 静态分配给语言带来限制

1. <font color="#33CCFF">递归</font>过程不被允许
2. 数据对象的<font color="#33CCFF">长度</font>和它在<font color="#33CCFF">内存中位置</font>，必须是在编译时可以知道的
3. 数据结构不能<font color="#33CCFF">动态建立</font>

#### 1.6.2.2. 静态分配的应用

1. Fortran语言被设计成允许静态存储分配
2. C语言程序的外部变量和程序中出现的常量都可以静态分配。
   1. 声明在函数外面
      1. 外部变量
   2. 声明在函数里面
      1. 静态局部变量
      2. 常量

### 1.6.3. 栈式存储分配

1. 栈式分配-主要用于-管理过程的**活动记录**
2. 局部变量 的 **生存期** 是过程活动的时间
3. 控制进入该过程时,
   1.  局部变量绑定到存储单元
4.  过程活动结束后, 
    1.  局部变量的空间释放
    2.  活动记录弹栈


#### 1.6.3.1. 活动树

1. 结点--过程活动
2. 根节点--主活动
3. 结点a是b的父节点--控制流从活动a进入b
4. 结点a在b的左边--活动a的生存期先于b
5. 控制处于某节点代表的活动--控制处于这个结点

#### 1.6.3.2. 运行栈

- 控制栈: 活动开始时压入栈,结束时从栈中弹出
- 把控制栈中的信息拓广到包括过程活动所需的所有局部信息(即活动记录)--控制栈中的信息包括活动的活动记录
- 当过程被调用
  - 新活动记录压入栈
  - 局部变量 绑定 其中存储单元
- 当调用的活动终止时
  - 活动记录退栈
  - 局部变量 不绑定 其中的存储单元 (恢复原来的绑定)
- 过程的每次调用都引起一个新的活动记录进栈
  - 所以, 过程的每次活动都会把局部变量绑定到新的存储单元

#### 1.6.3.3. 调用序列

- 其实就是程序
- 过程调用和过程返回都要执行一些代码来管理活动记录栈,保存或恢复机器状态等
  - 过程调用序列
    - 过程调用时执行的分配活动记录
    - 把信息填入它的域中
    - 使被调用过程可以开始执行的代码
  - 过程返回序列
    - 被调用过程返回时执行的恢复机器状态,释放被调用过程活动记录,是调用过程能够继续执行的代码

#### 1.6.3.4. (特例)过程的参数个数可变参数
   1. 函数返回值用寄存器传递
   2. 计算参数之后 实参逆序进栈 通过先拿到的参数可以推算后面参数的位置 (`printf("%d,%d\n");`)

#### 1.6.3.5. (特例)栈上可变长数据



1. 活动记录的长度在编译时不能确定的情况
   1. 编译时, 为数组分配数组指针的单元(活动记录中)
   2. 运行时, 指针指向在栈顶分配的数组存储空间

#### 1.6.3.6. 悬空引用


### 1.6.4. 堆式分配

1. 过程活动停止后, 局部名字的值还需要维持
2. 活动(被调用者)活的更长, 活动树不能正确描绘控制流
3. 特点
   1. 内存分配与释放按任意次序进行
   2. 堆中包含 交错的 正在使用的 & 已经释放的区域


### 1.6.5. 三种存储分配策略的比较
|              | 静态分配                   | 栈式分配      | 堆式分配 |
| ------------ | -------------------------- | ------------- | -------- |
| 存储空间     | 静态数据区                 | 栈区          | 堆区     |
| 使用范围     | 外部变量,静态局部变量,常量 | 局部变量,形参 | 动态变量 |
| 分配时间     | 程序开始前                 | 进入过程前    | 用户决定 |
| 释放时间     | 程序结束后                 | 过程结束      | 用户决定 |
| 地址计算时间 | 编译时                     | 运行时        | 运行时   |
| 存取速度     | 快                         | 慢            | 慢       |

## 1.7. 非局部名字的访问

1. 介绍
   1. 过程内部如何访问过程外部声明的名字
2. 静态作用域
   1. 无过程嵌套
   2. 又过程嵌套
3. 动态作用域

### 1.7.1. 无过程嵌套的静态作用域

1. 过程体中的非局部引用可以直接使用静态确定的地址（非局部数据此时就是全局数据）
2. 局部变量在栈顶的活动记录中，可以通过base_sp指针来访问
3. **无须深入栈中取数据**，无须访问链
4. **过程可以作为参数来传递**，**也可以作为结果来返回**

### 1.7.2. 有过程嵌套的静态作用域

#### 1.7.2.1. 访问链: 指向本活动最近的外围活动的记录

#### 1.7.2.2. 建立访问链

过程p:$n_{p}$  
过程x:$n_{x}$  
1. $n_{p}$ &lt; $n_{x}$
2. $n_{p}\geq n_{x}$
   1. $n_{p}-n_{x}+1$

### 1.7.3. 动态作用域

1. 被调用过程的非局部名字a和它在调用过程中引用的是**同样的**存储单元
   1. 基于**运行时的调用关系**
   2. 而不是基于静态作用域来确定
2. 新的绑定仅为被调用过程的局部名字建立，这些名字在被调用过程的活动记录中占用存储单元
3. 这一点与静态作用域没有区别
#### 1.7.3.1. 实现动态作用域的方法

1. 深访问
   1. 用控制链搜索运行栈，寻找包含该非局部名字的第一个活动记录
2. 浅访问(常用)
   1. 为每个名字在**静态分配的存储空间**中保存它的当前值
   2. 当过程p的新活动出现时，p的局部名字n使用在静态数据区分配给n的存储单元。n的先前值可以保存在p的**活动记录**中，当p的活动结束时再恢复

## 1.8. 参数传递

### 1.8.1. 引用调用

### 1.8.2. 换名调用(现在不用了 过时了)

# 2. 中间代码生成

1. 区分前端和后端
2. 优点
   
   1. 移植,与机器无关
3. 表示<font color="#33CCFF">(中间语言)</font>
   1. 后缀表示<font color="#f9bd10">后缀表达式</font>
      1. $E$: 变量/常数 -->它本身
      2. $E_1 op E_2$-->$E_1'E_{2}'op$
      3. $(E)$-->E':后缀表示不需要括号
   2. 图形表示<font color="#f9bd10">语法树/有向无环图(Directed Acyclic graph,DAG)</font>
      1. 例 $a=(-b+c*d)+c*d$
        ```mermaid
        graph TD
        assign-->a
        assign-->jia[+]
        jia-->+
        jia-->cheng[*]
        +-->uminus-->dii[b]
        +-->*
        *-->c
        *-->d
        cheng-->ci[c]
        cheng-->di[d] 
        ```

        后缀表达式: $a\ b\ uminus\ c\ d\ *\ +\ c\ d\ *\ +\ assign$
   3. 三地址代码<font color="#f9bd10">三地址代码</font>
      1. 静态单赋值形式,
          1. 就是重复赋值的话就加个角标
          2. $x$产生分支赋值- 就$x_{1},x_{2}$,最后合并$x_3=\phi (x_1,x_2)$

## 2.1. 声明语句

1. 符号表:为局部名字建立条目(类型,存储单元相对地址)
2. 分配存储单元
3. offset:相对地址(偏移量计数)

### 2.1.1. 符号表

1. mkTable(previous) 返回符号表指针
2. enter(table,name,type,offset) 为变量name
3. addWidth(table,width) 局部变量条目 的 累加宽度- 符号表的首部
4. enterProc(table,name,newtable) 过程名name


# 3. 代码生成

```mermaid
graph LR

源程序-->前端
前端--中间代码-->代码优化器
代码优化器--中间代码-->代码生成器
代码生成器-->目标程序
```
1. 绝对机器语言程序
    1. 内存固定地方
2. 可重定位目标模块
    1. 代码包含可重定位信息
3. 汇编语言程序
4. 指定的选择
    1. 逐条翻译,效率低下
5. 寄存器分配
    1. 选驻留寄存器的一组变量
6. 寄存器指派
    1. 选变量要驻留的寄存器
7. 计算次序的选择

- <font color="#33CCFF">指令代价
  - 附加代价  对应  指令以字计算的长度</font>

$$1+源地址模式附加代价+目的地址附加代价$$


| 模式       | 形式  | 地址                   | 附加代价 |
| ---------- | ----- | ---------------------- | -------- |
| 寄存器     | R     | R                      | 0        |
| 间接寄存器 | *R    | contents(R)            | 0        |
| 绝对地址   | M     | M                      | 1        |
| 变址       | c(R)  | c+contents(R)          | 1        |
| 间接变质   | *c(R) | contents(c+contens(R)) | 1        |
| 直接量     | #c    | c                      | 1        |

---
title: 3_语义分析
index_img: /post_index_img/编译原理.jpg
date: 2020-01-13 16:53:17
categories:
    - 编译原理
tags:
    - 编译原理
---


# 1. 语义分析

- 主流技术
  - 语法制导翻译技术
- 功能
  - 静态语义
    - 审查每个语法结构的.this(eg. 类型,运算,维数,越界)
  - 之后,翻译(真正的.this)
    - eg. 变量的存储分配/表达式的求值/语句的翻译(中间代码的生成)

## 1.1. 语义规则和产生式联系的两种方式

- 语义规则的两种描述方法

### 1.1.1. 语法制导的定义

* 带属性和规则的上下无关文法


#### 1.1.1.1. 基础文法

- 属性(翻译)文法
  - 定义
    - 语义规则函数无副作用 的 语法制导定义
    - 副作用
      - 过程调用/程序段-->可以看成 产生式左部非终结符 的虚拟综合属性
      - eg. 打印, 输出中间代码....
  - 语义信息是上下文有关的
  - 衔接: 上下文无关文法 & 程序语义

- 基础文法
  * 文法符号-->一组属性
  * 产生式-->一组语义规则(属性的计算规则)
  * 属性:  串 数值  类型  表引用 ... 
  * 语法制导定义中   文法-->**基础文法**

##### 1.1.1.1.1. 综合属性

* 属性b在左边, 产生式右部或者A的其他属性决定
  + 子节点来计算
* 终结符只有综合属性

###### 1.1.1.1.1.1. S属性定义自下而上计算

* 语法制导定义 --仅用综合属性 $\rightarrow$S-属性文法
* 使用<font color="#33CCFF">自下而上</font>分析器
* <font color="#f9bd10">边分析边计算</font>--不用单独(语义分析 编译分析)
* 分析完毕, 属性也计算完毕:<font color="#41b349">效率,限制节点访问次序</font>

``` mermaid
graph LR
输入串-->分析树-->依赖图-->拓扑排序-->语义规则计算次序
```

1. 注释分析树
   1. 结点的属性值都标注出来

2. 语法树
   1. 分析树的浓缩表示
   2. 内部节点: 算符 和 关键字
   3. 语法制导翻译 基于 分析树 或者 语法树
   4. 语法

      1. $mknode(op,left,right)$: 建立运算符结点
      2. $mkleaf(id, entry)$ : 建立标识符结点
      3. $mkleaf(num, val)$: 建立数结点

##### 1.1.1.1.2. 继承属性

* 左递归的消除会引起继承属性
  + 信息流动方式改变
* 属性<font color="#33CCFF">b在右边</font>,由A的属性或右部文法符号的属性决定
  + 节点的兄弟节点, 父节点, 自己的属性值来计算
* 方便表示语言结构 上下文依赖关系

###### 1.1.1.1.2.1. L属性定义<font color="#41b349">自上而下计算</font>

1. <font color="#f9bd10">,如果每个产生式 $A\rightarrow X_1,X_2 \cdot \cdot \cdot X_n$ 的每条语义规则计算的属性是
   1. A的综合属性；  (所引用的所有属性都计算完才能计算)
   2. 或者是$X_j$ 的继承属性，$1 \leqslant j \leqslant n$, 但它仅依赖：
      1. 该产生式中$X_j$左边符号$X_1, X_2, …, X_{j-1}$的属性；
      2. $A$的继承属性。
</font>
2. <font color="#f9bd10">$S$属性定义属于$L$属性定义</font>
3. 和S属性区别

   1.$S$: 只将产生式作为一个整体看待
   2.$S$: 语义规则附着在整个产生式上
   3.$L$: 和 属性所属 的 符号 在产生式中的位置有关

4. 翻译方案$\rightarrow$为了对$L$属性定义进行翻译

   1. 给出 使用语义规则 的计算的次序
   2. 文法符号相关的 **语义动作**, 用$\{\}$括起来 , 插入到产生式 右部的合适位置上
   3. 动作和分析 交错的方法, 表示: 动作的时机
   4. 建立翻译方案

      1. 只有综合属性: 
      2. 有综合属性和继承属性
<font color="#f9bd10">
         1. 必须: 产生式右边的符号的继承属性必须在先于这个符号的动作中计算出来
         2. 不能: <font color="#33CCFF">一个动作不能引用这个动作右边的符号的综合属性</font>
         3. 只有: 产生式左边非终结符的综合属性只有在它所引用的所有属性都计算出来以后才能计算。计算这种属性的动作通常可放在产生式右端的末尾。
</font>
5. 问题

   1. <font color="#41b349">自下而上</font> 分析中: 语义动作的执行是在使用产生式对句柄进行归约的时候
   2. 但是: L属性定义的继承属性的计算需要嵌在产生式右部不同的地方
   3. 解决:

      1. 通过改写文法，使得所有嵌入在产生式中间的动作变换成只在产生式的最右端出现

         1. 特殊情况一：删除翻译方案中嵌入的动作

            1. 在文法中加入产生$\epsilon$的标记非终结符，让每个嵌入动作由不同标记非终结符$M$代表，并把该动作放在产生式$M\rightarrow\epsilon$的右端

         2. 特殊情况二：分析栈上的继承属性

            1. 所依赖的属性在分析栈上的位置能静态确定
            2. 属性位置能预测

               1. **复写规则** b的继承属性copy了a的综合属性,那就只保存a的综合属性,b用的时候就在栈中取a的综合属性
         3. 一般情况 模拟继承属性的计算

            1. 不能与之属性值在栈中所放位置

               1. 通过标记非终结符M复写属性的值
6. 引进标记非终结符号对基础文法的影响
   1. 基础文法是LL(1)文法
      1. 没有影响，修改后的文法仍将保持LL(1)文法。
      2. 因为每个标记非终结符号是唯一的，而且只有唯一一个的产生式
   2. 基础文法是LR(1)文法
      1. 可能使修改后的文法变成非LR(1)文法

###### 1.1.1.1.2.2. 递归下降翻译器

###### 1.1.1.1.2.3. 用综合属性代替继承属性

#### 1.1.1.2. 语义规则

* 产生式  配备  一组属性 ---计算规则

##### 1.1.1.2.1. 语义规则函数

* 副作用:  打印 输出中间代码  修改全程量... 

##### 1.1.1.2.2. 属性文法

* 语义规则函数无副作用  的  语法制导定义


### 1.1.2. 语法制导的翻译方案

- 产生式右部插入相应的动作

# 2. 运行时存储空间的组织和管理

1. 通常的命令式编程语言
   1. 表现: 多个函数的实现和相互调用
   2. 入口函数-`mian()`
   3. 代码执行过程-依据过程调用关系形成一个(调用结构图)
   4. 辅助(存储空间)-每个过程的执行
      1. 过程的代码- 需要一定存储空间
      2. 过程中的局部变量-需要存储空间暂存
2. 词法,语法,语义分析后
   1. 生成目标代码前
      1. 程序的**静态正文**&实现这个程序的**运行时的活动**  联系起来
         1. 弄清楚 将来在 代码运行时刻
            1. 代码中的各种(变量,常量,等用户定义的量)如何存放,如何访问
3. 程序的执行过程中
   1. 程序中数据的存取 通过 与之对应的存储单元来进行的
4. 存储单元表示--标识符
   1. 对应的内存地址由编译程序或由其生成的目标程序运行时进行分配

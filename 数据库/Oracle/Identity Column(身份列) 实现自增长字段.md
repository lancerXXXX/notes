---
title: Identity Column(身份列) 实现自增长字段
index_img: /post_index_img/
date: 2020-04-03
categories:
    - 数据库
    - Oracle
tags:
    - 数据库
    - Oracle
---



> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 https://www.cnblogs.com/zyon/p/11067115.html

# Identity Column

Oracle 12c 提供的 Identity Column 特性简化了自增字段的定义。

声明自增字段通常有 3 种常见的用法，以下三种方式都支持`INSERT`语句中省略自增字段的插入，但有些许差别。

## 1. `GENERATED [ALWAYS] AS IDENTITY`

---------------------------------

此时`ALWAYS`关键字是可选的：

```plsql
create table tb_test (
    id number GENERATED ALWAYS AS IDENTITY,
    name varchar2(100)
);
```

此时试图插入指定`ID`字段的元组将报错，因为`ID`字段总是自动生成的，例如，执行下述语句：

```plsql
INSERT INTO TB_TEST VALUES(1, 'Zyon');
```

将报：

```plsql
ORA-32795: 无法插入到“始终生成”身份列
```

## 2. `GENERATED BY DEFAULT AS IDENTITY`
-----------------------------------

```plsql
create table tb_test2 (
    id number GENERATED BY DEFAULT AS IDENTITY,
    name varchar2(100)
);
```

此时可以插入指定`ID`列的元组，但不能指定`ID`列为`NULL`。

如：下述语句正常执行

```plsql
INSERT INTO TB_TEST2 VALUES(1, 'Zyon');
```

但如下语句将会报错：

```plsql
INSERT INTO TB_TEST2 VALUES(NULL, 'Darren');
```

## 3. `GENERATED BY DEFAULT ON NULL AS IDENTITY`
-------------------------------------------

```plsql
create table tb_test3 (
    id number GENERATED BY DEFAULT on null AS IDENTITY,
    name varchar2(100)
);
```

此时可以插入指定`ID`列的元组，也可以指定插入`ID`列为`NULL`。

如下语句正常执行：

```plsql
INSERT INTO TB_TEST3 VALUES(NULL, 'Darren');
```

**注意**

当自增列还要求唯一时，上述情形 2 和情形 3 将带来一个问题。

上述情形 2 和情形 3 允许插入指定自增列的元组，同时自增列自增时维护着下一次将要生成的序列号。所以如果同时支持自增，又插入了某个指定序列号的元组，后续插入时如果忽略自增列，那么当自增序列号达到指定序列号时，将会出现插入失败的情形。

但是此时自增计数器继续增加，所以下一次忽略自增列的插入可能又恢复正常，除非下一个序列号也被指定插入占用了。

例如：

忽略`ID`字段插入了 9 个元组（`ID`取值 1-9），突然指定`ID`为 10 插入第 10 个元组，然后又忽略`ID`字段插入时，因为 10 已经被占用，如果自增列要求唯一，将会出现冲突。

所以最好还是统一插入时 SQL 的形式，不要混用。



## 4. [identity 和sequence的区别](https://www.cnblogs.com/langtianya/archive/2013/05/08/3068020.html)

Identity字段与sequence的最大不同在于：identity只能在一个表中使用，多个表不可以共享identity；而sequence可以通过命名方式在同一个数据库内部的多个表中共享序列号发生器

